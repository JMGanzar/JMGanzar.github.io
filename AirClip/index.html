<!DOCTYPE html>
<html lang="es">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>AirClip</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', 'Roboto', 'Helvetica', 'Arial', sans-serif;
            background: #0a0a0a;
            color: #ffffff;
            min-height: 100vh;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            padding: 20px;
        }

        .container {
            max-width: 500px;
            width: 100%;
        }

        h1 {
            font-size: 2.5em;
            text-align: center;
            margin-bottom: 10px;
            font-weight: 300;
            letter-spacing: 2px;
        }

        .subtitle {
            text-align: center;
            color: #666;
            margin-bottom: 40px;
            font-size: 0.9em;
        }

        .mode-switch {
            display: flex;
            gap: 15px;
            margin-bottom: 40px;
        }

        .mode-btn {
            flex: 1;
            padding: 20px;
            background: #1a1a1a;
            border: 1px solid #333;
            border-radius: 8px;
            color: #666;
            font-size: 1.1em;
            cursor: pointer;
            transition: all 0.3s;
            font-weight: 400;
        }

        .mode-btn:hover {
            border-color: #555;
            color: #aaa;
        }

        .mode-btn.active {
            background: #2a2a2a;
            border-color: #00ff88;
            color: #00ff88;
        }

        .panel {
            display: none;
        }

        .panel.active {
            display: block;
        }

        textarea {
            width: 100%;
            min-height: 150px;
            padding: 20px;
            background: #1a1a1a;
            border: 1px solid #333;
            border-radius: 8px;
            color: #fff;
            font-size: 1em;
            font-family: 'Courier New', monospace;
            resize: vertical;
            margin-bottom: 20px;
        }

        textarea:focus {
            outline: none;
            border-color: #00ff88;
        }

        textarea::placeholder {
            color: #444;
        }

        .big-btn {
            width: 100%;
            padding: 25px;
            background: #00ff88;
            border: none;
            border-radius: 8px;
            color: #0a0a0a;
            font-size: 1.2em;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.2s;
            margin-bottom: 15px;
        }

        .big-btn:hover {
            background: #00dd77;
            transform: translateY(-2px);
        }

        .big-btn:active {
            transform: translateY(0);
        }

        .big-btn:disabled {
            background: #333;
            color: #666;
            cursor: not-allowed;
            transform: none;
        }

        .big-btn.listening {
            background: #ff4444;
            animation: pulse 1.5s infinite;
        }

        @keyframes pulse {
            0%, 100% { opacity: 1; }
            50% { opacity: 0.7; }
        }

        .status {
            text-align: center;
            padding: 15px;
            border-radius: 8px;
            margin-bottom: 20px;
            font-size: 0.9em;
            display: none;
        }

        .status.active {
            display: block;
        }

        .status.info {
            background: rgba(0, 123, 255, 0.1);
            border: 1px solid rgba(0, 123, 255, 0.3);
            color: #4da3ff;
        }

        .status.success {
            background: rgba(0, 255, 136, 0.1);
            border: 1px solid rgba(0, 255, 136, 0.3);
            color: #00ff88;
        }

        .status.error {
            background: rgba(255, 68, 68, 0.1);
            border: 1px solid rgba(255, 68, 68, 0.3);
            color: #ff4444;
        }

        .status.warning {
            background: rgba(255, 193, 7, 0.1);
            border: 1px solid rgba(255, 193, 7, 0.3);
            color: #ffc107;
        }

        .result-box {
            background: #1a1a1a;
            border: 1px solid #333;
            padding: 20px;
            border-radius: 8px;
            margin-bottom: 15px;
            word-break: break-all;
            font-family: 'Courier New', monospace;
            max-height: 300px;
            overflow-y: auto;
        }

        .result-actions {
            display: flex;
            gap: 10px;
        }

        .secondary-btn {
            flex: 1;
            padding: 15px;
            background: #1a1a1a;
            border: 1px solid #00ff88;
            border-radius: 8px;
            color: #00ff88;
            font-size: 1em;
            cursor: pointer;
            transition: all 0.2s;
        }

        .secondary-btn:hover {
            background: #2a2a2a;
        }

        .visualizer {
            width: 100%;
            height: 80px;
            background: #1a1a1a;
            border: 1px solid #333;
            border-radius: 8px;
            margin-bottom: 20px;
            position: relative;
            overflow: hidden;
        }

        .visualizer canvas {
            width: 100%;
            height: 100%;
        }

        .footer {
            text-align: center;
            color: #333;
            margin-top: 40px;
            font-size: 0.85em;
        }

        .char-counter {
            text-align: right;
            color: #666;
            font-size: 0.85em;
            margin-top: -15px;
            margin-bottom: 15px;
        }

        .char-counter.warning {
            color: #ffc107;
        }

        .progress-bar {
            width: 100%;
            height: 4px;
            background: #1a1a1a;
            border-radius: 2px;
            margin-bottom: 15px;
            overflow: hidden;
            display: none;
        }

        .progress-bar.active {
            display: block;
        }

        .progress-fill {
            height: 100%;
            background: #00ff88;
            width: 0%;
            transition: width 0.3s;
        }
    </style>
</head>
<body>
    <div class="container">
        <h1>AIRCLIP</h1>
        <p class="subtitle">TransmisiÃ³n de datos por audio</p>

        <div class="mode-switch">
            <button class="mode-btn active" onclick="switchMode('transmit')">
                TRANSMITIR
            </button>
            <button class="mode-btn" onclick="switchMode('listen')">
                ESCUCHAR
            </button>
        </div>

        <!-- TRANSMIT PANEL -->
        <div class="panel active" id="transmit-panel">
            <textarea 
                id="input-text"
                placeholder="Escribe o pega tu texto, URL..."
                oninput="updateCharCounter()"
            ></textarea>
            
            <div class="char-counter" id="char-counter">0 caracteres</div>

            <div class="progress-bar" id="transmit-progress">
                <div class="progress-fill" id="transmit-progress-fill"></div>
            </div>

            <div class="status" id="transmit-status"></div>

            <button class="big-btn" id="transmit-btn" onclick="transmit()">
                ðŸ”Š TRANSMITIR
            </button>
        </div>

        <!-- LISTEN PANEL -->
        <div class="panel" id="listen-panel">
            <div class="visualizer">
                <canvas id="visualizer-canvas"></canvas>
            </div>

            <div class="status" id="listen-status"></div>

            <button class="big-btn" id="listen-btn" onclick="toggleListen()">
                ðŸ‘‚ ESCUCHAR
            </button>

            <div id="result-container" style="display: none;">
                <div class="result-box" id="result-text"></div>
                <div class="result-actions">
                    <button class="secondary-btn" onclick="copyResult()">
                        ðŸ“‹ COPIAR
                    </button>
                    <button class="secondary-btn" id="open-url-btn" onclick="openURL()" style="display: none;">
                        ðŸ”— ABRIR
                    </button>
                </div>
            </div>
        </div>

        <div class="footer">
            Sin instalaciÃ³n Â· Open source Â· FSK encoding
        </div>
    </div>

    <script>
        // ============================================
        // CONFIGURACIÃ“N FSK
        // ============================================
        const CONFIG = {
            sampleRate: 44100,
            freq0: 1000,        // Frecuencia para bit 0
            freq1: 2000,        // Frecuencia para bit 1
            freqSync: 3000,     // Frecuencia de sincronizaciÃ³n
            bitDuration: 0.05,  // 50ms por bit = 20 bits/segundo
            syncDuration: 0.2,  // DuraciÃ³n del tono de sincronizaciÃ³n
            volume: 0.3,
            maxDirectLength: 100,
            detectionThreshold: 0.40   // Umbral alto para ignorar ruido ambiente
        };

        // ============================================
        // GLOBAL STATE
        // ============================================
        let audioContext = null;
        let isListening = false;
        let receivedData = '';
        let analyser = null;
        let microphone = null;

        let receivingData = false;
        let receivedBits = '';
        let expectedLength = 0;

        // âœ… NUEVO: contador de frames para validar el SYNC
        let syncFrameCount = 0;
        const SYNC_FRAMES_REQUIRED = 20; // ~330ms a 60fps â€” el tono de SYNC dura 200ms, sobra margen

        // ============================================
        // MODE SWITCHING
        // ============================================
        function switchMode(mode) {
            document.querySelectorAll('.mode-btn').forEach(btn => {
                btn.classList.remove('active');
            });
            event.target.classList.add('active');

            document.querySelectorAll('.panel').forEach(panel => {
                panel.classList.remove('active');
            });
            document.getElementById(mode + '-panel').classList.add('active');

            hideStatus('transmit-status');
            hideStatus('listen-status');
            
            if (isListening) {
                stopListening();
            }
        }

        // ============================================
        // TRANSMIT
        // ============================================
        async function transmit() {
            let text = document.getElementById('input-text').value.trim();

            if (!text) {
                showStatus('transmit-status', 'Escribe algo primero', 'warning');
                return;
            }

            const btn = document.getElementById('transmit-btn');
            btn.disabled = true;

            try {
                const isURL = /^https?:\/\//i.test(text);

                if (text.length > CONFIG.maxDirectLength) {
                    showStatus('transmit-status', `Texto largo detectado (${text.length} chars). Generando URL temporal...`, 'info');
                    
                    const shortURL = await uploadAndShorten(text);
                    
                    if (shortURL) {
                        text = shortURL;
                        showStatus('transmit-status', `âœ… URL generada. Transmitiendo ${text}...`, 'info');
                    } else {
                        showStatus('transmit-status', 'Error generando URL. Prueba con texto mÃ¡s corto.', 'error');
                        btn.disabled = false;
                        return;
                    }
                } else if (isURL && text.length > 50) {
                    showStatus('transmit-status', 'Acortando URL...', 'info');
                    const shortened = await shortenURL(text);
                    if (shortened && shortened.length < text.length) {
                        text = shortened;
                    }
                }

                showStatus('transmit-status', 'ðŸ”Š Transmitiendo... Acerca el otro dispositivo', 'info');
                document.getElementById('transmit-progress').classList.add('active');

                await transmitFSK(text);

                showStatus('transmit-status', 'âœ… TransmisiÃ³n completada', 'success');

            } catch (error) {
                showStatus('transmit-status', 'âŒ Error: ' + error.message, 'error');
                console.error(error);
            } finally {
                btn.disabled = false;
                document.getElementById('transmit-progress').classList.remove('active');
                document.getElementById('transmit-progress-fill').style.width = '0%';
            }
        }

        async function transmitFSK(text) {
            if (!audioContext) {
                audioContext = new (window.AudioContext || window.webkitAudioContext)();
            }

            const binary = textToBinary(text);
            console.log('Transmitiendo:', text);
            console.log('Binario:', binary);

            const syncSamples = CONFIG.sampleRate * CONFIG.syncDuration;
            const bitSamples = CONFIG.sampleRate * CONFIG.bitDuration;
            const totalSamples = syncSamples * 2 + (binary.length * bitSamples);

            const buffer = audioContext.createBuffer(1, totalSamples, CONFIG.sampleRate);
            const data = buffer.getChannelData(0);

            let offset = 0;

            // SYNC inicial
            offset = generateTone(data, offset, CONFIG.freqSync, syncSamples);

            // Bits de datos
            for (let i = 0; i < binary.length; i++) {
                const bit = binary[i];
                const freq = bit === '1' ? CONFIG.freq1 : CONFIG.freq0;
                offset = generateTone(data, offset, freq, bitSamples);

                const progress = ((i + 1) / binary.length) * 100;
                document.getElementById('transmit-progress-fill').style.width = progress + '%';
            }

            // SYNC final
            offset = generateTone(data, offset, CONFIG.freqSync, syncSamples);

            const source = audioContext.createBufferSource();
            source.buffer = buffer;
            source.connect(audioContext.destination);
            source.start();

            return new Promise(resolve => {
                source.onended = resolve;
            });
        }

        function generateTone(buffer, offset, frequency, samples) {
            for (let i = 0; i < samples; i++) {
                const t = (offset + i) / CONFIG.sampleRate;
                buffer[offset + i] = Math.sin(2 * Math.PI * frequency * t) * CONFIG.volume;
            }
            return offset + samples;
        }

        function textToBinary(text) {
            let binary = '';
            binary += text.length.toString(2).padStart(8, '0');
            for (let i = 0; i < text.length; i++) {
                const charCode = text.charCodeAt(i);
                binary += charCode.toString(2).padStart(8, '0');
            }
            return binary;
        }

        // ============================================
        // URL SHORTENING & UPLOAD
        // ============================================
        async function shortenURL(url) {
            try {
                const response = await fetch(`https://tinyurl.com/api-create.php?url=${encodeURIComponent(url)}`);
                const shortURL = await response.text();
                return shortURL || url;
            } catch (error) {
                console.error('Error acortando URL:', error);
                return url;
            }
        }

        async function uploadAndShorten(text) {
            try {
                const formData = new FormData();
                formData.append('content', text);
                formData.append('syntax', 'text');
                formData.append('expiry_days', 1);

                const response = await fetch('https://dpaste.com/api/', {
                    method: 'POST',
                    body: formData
                });

                if (response.ok) {
                    const url = await response.text();
                    const cleanURL = url.trim() + '.txt';
                    return await shortenURL(cleanURL);
                }

                return null;

            } catch (error) {
                console.error('Error subiendo contenido:', error);
                return null;
            }
        }

        // ============================================
        // LISTEN
        // ============================================
        async function toggleListen() {
            if (isListening) {
                stopListening();
            } else {
                startListening();
            }
        }

        async function startListening() {
            try {
                if (!audioContext) {
                    audioContext = new (window.AudioContext || window.webkitAudioContext)();
                }

                const stream = await navigator.mediaDevices.getUserMedia({ 
                    audio: {
                        echoCancellation: false,
                        noiseSuppression: false,
                        autoGainControl: false,
                        sampleRate: CONFIG.sampleRate
                    }
                });

                microphone = audioContext.createMediaStreamSource(stream);
                analyser = audioContext.createAnalyser();
                analyser.fftSize = 8192;
                analyser.smoothingTimeConstant = 0.0; // Sin suavizado: los clics duran 1 frame, no se prolongan

                microphone.connect(analyser);

                isListening = true;
                const btn = document.getElementById('listen-btn');
                btn.textContent = 'â¹ï¸ DETENER';
                btn.classList.add('listening');

                showStatus('listen-status', 'ðŸ‘‚ Escuchando... Reproduce el sonido', 'info');

                visualize();
                detectFSK();

                window.currentStream = stream;

            } catch (error) {
                showStatus('listen-status', 'âŒ Error: ' + error.message, 'error');
                console.error(error);
                isListening = false;
            }
        }

        function stopListening() {
            isListening = false;

            // âœ… CORREGIDO: resetear todo el estado al parar
            syncFrameCount = 0;
            receivingData = false;
            receivedBits = '';
            expectedLength = 0;

            const btn = document.getElementById('listen-btn');
            btn.textContent = 'ðŸ‘‚ ESCUCHAR';
            btn.classList.remove('listening');

            if (window.currentStream) {
                window.currentStream.getTracks().forEach(track => track.stop());
                window.currentStream = null;
            }

            if (microphone) {
                microphone.disconnect();
                microphone = null;
            }

            hideStatus('listen-status');
        }

        function detectFSK() {
            if (!isListening) return;

            const bufferLength = analyser.frequencyBinCount;
            const dataArray = new Uint8Array(bufferLength);
            analyser.getByteFrequencyData(dataArray);

            const freqResolution = CONFIG.sampleRate / analyser.fftSize;

            const idx0    = Math.floor(CONFIG.freq0    / freqResolution);
            const idx1    = Math.floor(CONFIG.freq1    / freqResolution);
            const idxSync = Math.floor(CONFIG.freqSync / freqResolution);

            const amp0    = dataArray[idx0];
            const amp1    = dataArray[idx1];
            const ampSync = dataArray[idxSync];

            const threshold = 255 * CONFIG.detectionThreshold;

            // âœ… CORREGIDO: el SYNC debe sostenerse Y ser dominante sobre las demÃ¡s frecuencias.
            // En un clic o estÃ¡tica, TODA la banda recibe energÃ­a por igual â†’ ampSync no destaca.
            // En un tono puro de 3000Hz, ampSync es mucho mayor que amp0 y amp1.
            const syncIsDominant = ampSync > threshold &&
                                   ampSync > amp0 * 2.5 &&
                                   ampSync > amp1 * 2.5;

            if (!receivingData) {
                if (syncIsDominant) {
                    syncFrameCount++;
                    if (syncFrameCount >= SYNC_FRAMES_REQUIRED) {
                        console.log('ðŸŽ¯ SYNC sostenido y dominante - Iniciando recepciÃ³n');
                        receivingData = true;
                        syncFrameCount = 0;
                        receivedBits = '';
                        expectedLength = 0;
                        showStatus('listen-status', 'ðŸ“¡ Recibiendo datos...', 'info');
                    }
                } else {
                    syncFrameCount = 0; // si se interrumpe o no es dominante, reinicia
                }
            }

            // Recibir bits
            if (receivingData) {
                if (amp1 > threshold && amp1 > amp0) {
                    receivedBits += '1';
                } else if (amp0 > threshold && amp0 > amp1) {
                    receivedBits += '0';
                }

                // Leer longitud (primeros 8 bits)
                if (expectedLength === 0 && receivedBits.length >= 8) {
                    expectedLength = parseInt(receivedBits.substr(0, 8), 2);
                    console.log('ðŸ“ Longitud esperada:', expectedLength, 'caracteres');
                }

                // Verificar si hemos recibido todo
                if (expectedLength > 0) {
                    const expectedBits = 8 + (expectedLength * 8);
                    if (receivedBits.length >= expectedBits) {
                        const text = binaryToText(receivedBits);
                        if (text) {
                            console.log('âœ… Recibido:', text);
                            handleReceivedData(text);
                            stopListening();
                            return;
                        }
                    }
                }
            }

            requestAnimationFrame(detectFSK);
        }

        function binaryToText(binary) {
            try {
                const length = parseInt(binary.substr(0, 8), 2);

                let text = '';
                for (let i = 0; i < length; i++) {
                    const start = 8 + (i * 8);
                    const byte = binary.substr(start, 8);
                    if (byte.length === 8) {
                        const charCode = parseInt(byte, 2);
                        text += String.fromCharCode(charCode);
                    }
                }

                return text;
            } catch (error) {
                console.error('Error decodificando:', error);
                return null;
            }
        }

        function handleReceivedData(text) {
            receivedData = text;
            document.getElementById('result-text').textContent = text;
            document.getElementById('result-container').style.display = 'block';

            const isURL = /^https?:\/\//i.test(text);
            document.getElementById('open-url-btn').style.display = isURL ? 'block' : 'none';

            showStatus('listen-status', 'âœ… Recibido correctamente', 'success');
        }

        function visualize() {
            const canvas = document.getElementById('visualizer-canvas');
            const ctx = canvas.getContext('2d');
            canvas.width = canvas.offsetWidth * 2;
            canvas.height = canvas.offsetHeight * 2;
            ctx.scale(2, 2);

            const bufferLength = analyser.frequencyBinCount;
            const dataArray = new Uint8Array(bufferLength);

            function draw() {
                if (!isListening) return;

                requestAnimationFrame(draw);
                analyser.getByteFrequencyData(dataArray);

                ctx.fillStyle = '#1a1a1a';
                ctx.fillRect(0, 0, canvas.width / 2, canvas.height / 2);

                const barWidth = (canvas.width / 2) / bufferLength * 2;
                let x = 0;

                for (let i = 0; i < bufferLength; i++) {
                    const barHeight = (dataArray[i] / 255) * (canvas.height / 2);
                    ctx.fillStyle = `rgba(0, 255, 136, ${dataArray[i] / 255})`;
                    ctx.fillRect(x, (canvas.height / 2) - barHeight, barWidth, barHeight);
                    x += barWidth + 1;
                }
            }

            draw();
        }

        // ============================================
        // RESULT ACTIONS
        // ============================================
        function copyResult() {
            navigator.clipboard.writeText(receivedData).then(() => {
                showStatus('listen-status', 'âœ… Copiado al portapapeles', 'success');
                setTimeout(() => hideStatus('listen-status'), 2000);
            });
        }

        function openURL() {
            if (receivedData && /^https?:\/\//i.test(receivedData)) {
                window.open(receivedData, '_blank');
            }
        }

        // ============================================
        // UI HELPERS
        // ============================================
        function updateCharCounter() {
            const text = document.getElementById('input-text').value;
            const counter = document.getElementById('char-counter');
            const len = text.length;

            counter.textContent = `${len} caracteres`;

            if (len > CONFIG.maxDirectLength) {
                counter.textContent += ` (se generarÃ¡ URL temporal)`;
                counter.classList.add('warning');
            } else {
                counter.classList.remove('warning');
            }
        }

        function showStatus(id, message, type) {
            const el = document.getElementById(id);
            el.textContent = message;
            el.className = `status active ${type}`;
        }

        function hideStatus(id) {
            const el = document.getElementById(id);
            el.className = 'status';
        }
    </script>
</body>
</html>
